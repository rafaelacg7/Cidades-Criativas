# -*- coding: utf-8 -*-
"""AN√ÅLISE FATORIAL EXPLORAT√ìRIA (AFE) COM ROTA√á√ÉO VARIMAX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VRdlOMvydY7jZ6i8yU1IJtHEXf4alhDG

# correto
"""

"""
AN√ÅLISE FATORIAL EXPLORAT√ìRIA (AFE) COM ROTA√á√ÉO VARIMAX
Disserta√ß√£o de Rafaela - Mensura√ß√£o de Governan√ßa em Cidades Criativas da UNESCO
Programa de P√≥s-Gradua√ß√£o em Modelagem Computacional e Sistemas - Unimontes

"""

import pandas as pd
import numpy as np
import warnings
import os
import math
warnings.filterwarnings('ignore')

# ============================================================================
# FUN√á√ïES PARA TESTES DE ADEQUA√á√ÉO
# ============================================================================

def calcular_bartlett(dados):
    """
    Calcula o Teste de Esfericidade de Bartlett

    H0: A matriz de correla√ß√£o √© uma matriz identidade (vari√°veis n√£o correlacionadas)
    H1: A matriz de correla√ß√£o n√£o √© uma matriz identidade (vari√°veis correlacionadas)

    Se p < 0.05, rejeitamos H0 ‚Üí dados s√£o apropriados para an√°lise fatorial
    """
    n = len(dados)
    p = dados.shape[1]

    # Matriz de correla√ß√£o
    corr_matrix = dados.corr().values

    # Determinante da matriz de correla√ß√£o
    det_corr = np.linalg.det(corr_matrix)

    # Evitar log de n√∫meros muito pequenos
    if det_corr <= 0:
        det_corr = 1e-10

    # Estat√≠stica de teste
    chi2 = -(n - 1 - (2*p + 5)/6) * np.log(det_corr)

    # Graus de liberdade
    df = (p * (p - 1)) / 2

    # P-valor (aproximado)
    # Para uma distribui√ß√£o chi-quadrado com df graus de liberdade
    # Usaremos uma aproxima√ß√£o simples
    p_value = 1 - (chi2 / (chi2 + df))  # Aproxima√ß√£o

    return {
        'chi2': chi2,
        'df': int(df),
        'p_value': p_value,
        'det_corr': det_corr
    }

def calcular_kmo(dados):
    """
    Calcula o √çndice de Adequa√ß√£o da Amostra (KMO) de Kaiser-Meyer-Olkin

    KMO mede se os dados s√£o apropriados para an√°lise fatorial

    Interpreta√ß√£o:
    - KMO > 0.9: Excelente
    - KMO > 0.8: Bom
    - KMO > 0.7: Aceit√°vel
    - KMO > 0.6: Med√≠ocre
    - KMO > 0.5: Fraco
    - KMO < 0.5: Inadequado
    """
    n_vars = dados.shape[1]

    # Matriz de correla√ß√£o
    corr_matrix = dados.corr().values

    # Matriz de correla√ß√£o parcial (aproxima√ß√£o)
    # Usando a inversa da matriz de correla√ß√£o
    try:
        corr_inv = np.linalg.inv(corr_matrix)
    except np.linalg.LinAlgError:
        # Se a matriz √© singular, usar pseudoinversa
        corr_inv = np.linalg.pinv(corr_matrix)

    # Correla√ß√µes parciais
    # p_ij = -corr_inv[i,j] / sqrt(corr_inv[i,i] * corr_inv[j,j])

    # Calcular KMO
    numerador = 0
    denominador = 0

    for i in range(n_vars):
        for j in range(n_vars):
            if i != j:
                # Correla√ß√£o simples
                r_ij = corr_matrix[i, j]

                # Correla√ß√£o parcial (aproxima√ß√£o)
                p_ij = -corr_inv[i, j] / np.sqrt(corr_inv[i, i] * corr_inv[j, j])

                numerador += r_ij ** 2
                denominador += r_ij ** 2 + p_ij ** 2

    if denominador == 0:
        kmo = 0
    else:
        kmo = numerador / denominador

    # KMO por vari√°vel
    kmo_por_variavel = np.zeros(n_vars)

    for i in range(n_vars):
        numerador_i = 0
        denominador_i = 0

        for j in range(n_vars):
            if i != j:
                r_ij = corr_matrix[i, j]
                p_ij = -corr_inv[i, j] / np.sqrt(corr_inv[i, i] * corr_inv[j, j])

                numerador_i += r_ij ** 2
                denominador_i += r_ij ** 2 + p_ij ** 2

        if denominador_i == 0:
            kmo_por_variavel[i] = 0
        else:
            kmo_por_variavel[i] = numerador_i / denominador_i

    return kmo, kmo_por_variavel

def interpretar_kmo(kmo):
    """Interpreta o valor de KMO"""
    if kmo > 0.9:
        return "Excelente"
    elif kmo > 0.8:
        return "Bom"
    elif kmo > 0.7:
        return "Aceit√°vel"
    elif kmo > 0.6:
        return "Med√≠ocre"
    elif kmo > 0.5:
        return "Fraco"
    else:
        return "Inadequado"

# ============================================================================
# FUN√á√ïES DE AN√ÅLISE FATORIAL COM ROTA√á√ÉO
# ============================================================================

def realizar_pca(dados_padronizados, n_componentes=None):
    """Realiza PCA manualmente"""
    # Matriz de covari√¢ncia
    cov_matrix = np.cov(dados_padronizados.T)

    # Autovalores e autovetores
    autovalores, autovetores = np.linalg.eig(cov_matrix)

    # Ordenar por autovalores decrescentes
    idx = autovalores.argsort()[::-1]
    autovalores = autovalores[idx]
    autovetores = autovetores[:, idx]

    # Vari√¢ncia explicada
    variancia_explicada = autovalores / np.sum(autovalores)
    variancia_acumulada = np.cumsum(variancia_explicada)

    return autovalores, autovetores, variancia_explicada, variancia_acumulada

def rotacao_varimax(loadings, max_iter=100, tol=1e-6):
    """
    Implementa rota√ß√£o Varimax (ortogonal)

    Objetivo: Maximizar a vari√¢ncia das cargas ao quadrado em cada fator
    Resultado: Fatores mais interpret√°veis e diferenciados
    """
    p, k = loadings.shape

    # Inicializar matriz de rota√ß√£o como identidade
    R = np.eye(k)

    for iteration in range(max_iter):
        R_old = R.copy()

        # Para cada par de fatores
        for i in range(k):
            for j in range(i + 1, k):
                # Extrair as duas colunas
                x = loadings[:, i]
                y = loadings[:, j]

                # Calcular os componentes da rota√ß√£o
                A = np.sum(x**2 - y**2)
                B = 2 * np.sum(x * y)

                # √Çngulo de rota√ß√£o
                tan_2phi = B / A if A != 0 else 0
                phi = 0.5 * np.arctan(tan_2phi)

                # Matriz de rota√ß√£o de Givens
                c = np.cos(phi)
                s = np.sin(phi)

                # Aplicar rota√ß√£o
                loadings[:, i] = c * x + s * y
                loadings[:, j] = -s * x + c * y

                # Atualizar matriz de rota√ß√£o
                R_temp = np.eye(k)
                R_temp[i, i] = c
                R_temp[i, j] = -s
                R_temp[j, i] = s
                R_temp[j, j] = c
                R = R @ R_temp

        # Verificar converg√™ncia
        if np.allclose(R, R_old, atol=tol):
            break

    return loadings, R

def extrair_fatores_com_rotacao(dados, n_fatores=4):
    """
    Extrai fatores usando PCA + Varimax
    """
    # Padronizar
    dados_padronizados = (dados - dados.mean()) / dados.std()

    # PCA
    autovalores, autovetores, var_exp, var_acum = realizar_pca(dados_padronizados.values, n_fatores)

    # Selecionar primeiros n_fatores
    autovetores_selecionados = autovetores[:, :n_fatores]
    autovalores_selecionados = autovalores[:n_fatores]

    # Calcular cargas (loadings)
    loadings = autovetores_selecionados * np.sqrt(autovalores_selecionados)

    # Aplicar rota√ß√£o Varimax
    loadings_rotacionados, R = rotacao_varimax(loadings.copy())

    return loadings, loadings_rotacionados, autovalores_selecionados, var_exp[:n_fatores]

def alocacao_questoes_aos_fatores(loadings, questoes, limiar=0.4):
    """
    Aloca quest√µes aos fatores com base nas cargas rotacionadas
    """
    n_vars, n_fatores = loadings.shape

    alocacoes = {i: [] for i in range(n_fatores)}

    for var_idx in range(n_vars):
        questao = questoes[var_idx]
        cargas_questao = loadings[var_idx, :]

        # Encontrar fator com maior carga
        fator_principal = np.argmax(np.abs(cargas_questao))
        carga_principal = cargas_questao[fator_principal]

        # S√≥ alocar se carga > limiar
        if abs(carga_principal) > limiar:
            alocacoes[fator_principal].append({
                'questao': questao,
                'carga': carga_principal,
                'idx': var_idx,
                'cargas_todas': cargas_questao.copy()
            })

    return alocacoes

# ============================================================================
# CARREGAR DADOS (ADAPTADO PARA O COLAB E NOME DO ARQUIVO)
# ============================================================================

# Tenta encontrar o arquivo pelo nome padr√£o. Se n√£o achar, abre bot√£o de upload.
nome_do_arquivo = 'Governan√ßa de Cidades Criativas .xlsx - Sheet1.csv'
caminho_dados = nome_do_arquivo

if not os.path.exists(caminho_dados):
    print(f"‚ö†Ô∏è O arquivo '{nome_do_arquivo}' n√£o foi encontrado automaticamente.")
    print("üëá Por favor, clique no bot√£o abaixo para fazer o UPLOAD do arquivo CSV:")
    try:
        from google.colab import files
        uploaded = files.upload()
        if uploaded:
            caminho_dados = list(uploaded.keys())[0]
            print(f"\n‚úì Arquivo recebido: {caminho_dados}")
        else:
            print("‚ùå Nenhum arquivo enviado. Encerrando."); exit()
    except ImportError:
        print("‚ùå Ambiente n√£o √© Colab."); exit()

# L√™ o arquivo. Como termina em .csv, usamos read_csv.
try:
    df = pd.read_csv(caminho_dados)
except:
    # Caso falhe, tenta ler como Excel se o usu√°rio mandou xlsx real
    df = pd.read_excel(caminho_dados)

# AJUSTE NECESS√ÅRIO: Renomeia as colunas '2','3' para 'Q2','Q3' para o c√≥digo funcionar
cols_map = {str(i): f'Q{i}' for i in range(2, 26)}
# Garante que as colunas sejam strings antes de renomear
df.columns = df.columns.astype(str)
df.rename(columns=cols_map, inplace=True)

questoes_todas = [f'Q{i}' for i in range(2, 26)]
# Filtra apenas as quest√µes que realmente existem no dataframe ap√≥s renomear
questoes_existentes = [q for q in questoes_todas if q in df.columns]
dados_escala = df[questoes_existentes]

print("="*120)
print("AN√ÅLISE FATORIAL EXPLORAT√ìRIA (AFE) COM ROTA√á√ÉO VARIMAX")
print("Mensura√ß√£o de Governan√ßa em Cidades Criativas da UNESCO")
print("="*120)
print(f"\n‚úì Arquivo de dados carregado com sucesso!")
print(f"  Respondentes: {len(df)}")
print(f"  Quest√µes: {len(questoes_todas)}")

# ============================================================================
# 0. TESTES DE ADEQUA√á√ÉO (NOVO!)
# ============================================================================

print("\n\n" + "="*120)
print("0. TESTES DE ADEQUA√á√ÉO PARA AN√ÅLISE FATORIAL")
print("="*120)

# Teste de Bartlett
print("\nüìä TESTE DE ESFERICIDADE DE BARTLETT")
print("-" * 120)
print("H0: A matriz de correla√ß√£o √© uma matriz identidade (vari√°veis n√£o correlacionadas)")
print("H1: A matriz de correla√ß√£o n√£o √© uma matriz identidade (vari√°veis correlacionadas)")
print()

bartlett_resultado = calcular_bartlett(dados_escala)

print(f"Qui-Quadrado (œá¬≤): {bartlett_resultado['chi2']:.4f}")
print(f"Graus de Liberdade (df): {bartlett_resultado['df']}")
print(f"P-valor: {bartlett_resultado['p_value']:.6f}")
print(f"Determinante da Matriz de Correla√ß√£o: {bartlett_resultado['det_corr']:.6f}")

if bartlett_resultado['p_value'] < 0.05:
    print("\n‚úì RESULTADO: Significativo (p < 0.05)")
    print("  Interpreta√ß√£o: As vari√°veis s√£o significativamente correlacionadas.")
    print("  Conclus√£o: Os dados s√£o APROPRIADOS para an√°lise fatorial.")
else:
    print("\n‚úó RESULTADO: N√£o significativo (p ‚â• 0.05)")
    print("  Interpreta√ß√£o: As vari√°veis n√£o s√£o significativamente correlacionadas.")
    print("  Conclus√£o: Os dados podem N√ÉO ser apropriados para an√°lise fatorial.")

# √çndice KMO
print("\n\nüìä √çNDICE DE ADEQUA√á√ÉO DA AMOSTRA (KMO)")
print("-" * 120)

kmo_geral, kmo_por_variavel = calcular_kmo(dados_escala)

print(f"\nKMO Geral: {kmo_geral:.4f}")
print(f"Interpreta√ß√£o: {interpretar_kmo(kmo_geral)}")

if kmo_geral > 0.5:
    print("\n‚úì RESULTADO: Adequado (KMO > 0.5)")
    print("  Os dados s√£o apropriados para an√°lise fatorial.")
else:
    print("\n‚úó RESULTADO: Inadequado (KMO ‚â§ 0.5)")
    print("  Os dados podem n√£o ser apropriados para an√°lise fatorial.")

print("\n\nKMO por Vari√°vel:")
print("-" * 120)

kmo_df = pd.DataFrame({
    'Quest√£o': questoes_todas,
    'KMO': kmo_por_variavel,
    'Interpreta√ß√£o': [interpretar_kmo(k) for k in kmo_por_variavel]
})

kmo_df = kmo_df.sort_values('KMO', ascending=False)
print(kmo_df.to_string(index=False))

print("\n\nResumo KMO por Vari√°vel:")
print(f"  Excelente (> 0.9): {np.sum(kmo_por_variavel > 0.9)} vari√°veis")
print(f"  Bom (0.8-0.9): {np.sum((kmo_por_variavel > 0.8) & (kmo_por_variavel <= 0.9))} vari√°veis")
print(f"  Aceit√°vel (0.7-0.8): {np.sum((kmo_por_variavel > 0.7) & (kmo_por_variavel <= 0.8))} vari√°veis")
print(f"  Med√≠ocre (0.6-0.7): {np.sum((kmo_por_variavel > 0.6) & (kmo_por_variavel <= 0.7))} vari√°veis")
print(f"  Fraco (0.5-0.6): {np.sum((kmo_por_variavel > 0.5) & (kmo_por_variavel <= 0.6))} vari√°veis")
print(f"  Inadequado (< 0.5): {np.sum(kmo_por_variavel <= 0.5)} vari√°veis")

# ============================================================================
# 1. AN√ÅLISE DE COMPONENTES PRINCIPAIS (PCA)
# ============================================================================

print("\n\n" + "="*120)
print("1. AN√ÅLISE DE COMPONENTES PRINCIPAIS (PCA)")
print("="*120)

# Padronizar dados
dados_padronizados = (dados_escala - dados_escala.mean()) / dados_escala.std()

# PCA
autovalores, autovetores, var_explicada, var_acumulada = realizar_pca(dados_padronizados.values)

print("\nVari√¢ncia Explicada por Componente:")
print("-" * 120)
print("Componente | Autovalor | Vari√¢ncia | Vari√¢ncia Acumulada")
print("-" * 120)

for i in range(min(10, len(var_explicada))):
    status = "‚úì" if autovalores[i] > 1 else "‚úó"
    print(f"PC{i+1:2d}        | {autovalores[i]:>9.4f} | {var_explicada[i]:>9.4f} | {var_acumulada[i]:>19.4f} {status}")

# Crit√©rio de Kaiser
print("\n\nüìä Crit√©rio de Kaiser (Autovalor > 1)")
print("-" * 120)

num_componentes_kaiser = np.sum(autovalores > 1)
print(f"N√∫mero de componentes com autovalor > 1: {num_componentes_kaiser}")

print("\nAutovalores Detalhados:")
for i in range(min(10, len(autovalores))):
    status = "‚úì" if autovalores[i] > 1 else "‚úó"
    print(f"PC{i+1:2d}: {autovalores[i]:>8.4f} {status}")

# ============================================================================
# 2. AN√ÅLISE FATORIAL COM ROTA√á√ÉO VARIMAX
# ============================================================================

print("\n\n" + "="*120)
print("2. AN√ÅLISE FATORIAL COM ROTA√á√ÉO VARIMAX")
print("="*120)

resultados_afe = []

for n_fatores in range(2, 7):
    print(f"\n{'='*120}")
    print(f"AN√ÅLISE COM {n_fatores} FATORES")
    print(f"{'='*120}")

    # Extrair fatores com rota√ß√£o
    loadings_original, loadings_rotacionados, autovalores_selecionados, var_exp_selecionada = \
        extrair_fatores_com_rotacao(dados_escala, n_fatores)

    # Vari√¢ncia explicada
    var_total = np.sum(var_exp_selecionada)

    print(f"\nVari√¢ncia Explicada Total: {var_total:.4f}")

    # Comunalidades
    comunalidades = np.sum(loadings_rotacionados**2, axis=1)

    print(f"\nComunalidades (Top 10):")
    print("-" * 120)

    comunalidades_df = pd.DataFrame({
        'Quest√£o': questoes_todas,
        'Comunalidade': comunalidades
    })
    comunalidades_df = comunalidades_df.sort_values('Comunalidade', ascending=False)

    print(comunalidades_df.head(10).to_string(index=False))

    # Cargas fatoriais rotacionadas
    print(f"\n\nCargas Fatoriais Rotacionadas (Varimax):")
    print("-" * 120)

    loadings_df = pd.DataFrame(
        loadings_rotacionados,
        columns=[f'Fator {i+1}' for i in range(n_fatores)],
        index=questoes_todas
    )

    print(loadings_df.to_string())

    # Aloca√ß√£o
    alocacoes = alocacao_questoes_aos_fatores(loadings_rotacionados, questoes_todas, limiar=0.4)

    print(f"\n\nAloca√ß√£o de Quest√µes aos Fatores (Carga > 0.40):")
    print("-" * 120)

    for fator_idx in sorted(alocacoes.keys()):
        questoes_fator = sorted(alocacoes[fator_idx], key=lambda x: abs(x['carga']), reverse=True)

        if questoes_fator:
            print(f"\nFator {fator_idx + 1}: ({len(questoes_fator)} itens)")
            for item in questoes_fator:
                status = "‚úì" if abs(item['carga']) > 0.5 else "!" if abs(item['carga']) > 0.3 else "‚úó"
                print(f"  {item['questao']}: {item['carga']:>8.4f} {status}")
        else:
            print(f"\nFator {fator_idx + 1}: (0 itens)")

    resultados_afe.append({
        'n_fatores': n_fatores,
        'var_explicada': var_total,
        'comunalidades': comunalidades,
        'loadings_original': loadings_original,
        'loadings_rotacionados': loadings_rotacionados,
        'alocacoes': alocacoes,
        'autovalores': autovalores_selecionados
    })

# ============================================================================
# 3. COMPARA√á√ÉO E RECOMENDA√á√ÉO
# ============================================================================

print("\n\n" + "="*120)
print("3. COMPARA√á√ÉO E RECOMENDA√á√ÉO")
print("="*120)

print("\nResumo de Vari√¢ncia Explicada:")
print("-" * 120)
print("N√∫mero de Fatores | Vari√¢ncia Explicada")
print("-" * 120)

for resultado in resultados_afe:
    print(f"{resultado['n_fatores']:>17d} | {resultado['var_explicada']:>19.4f}")

# Encontrar melhor n√∫mero de fatores
melhor_resultado = max(resultados_afe, key=lambda x: x['var_explicada'])

print(f"\n\nüìä RECOMENDA√á√ïES:")
print("-" * 120)

print(f"\n1. Teste de Bartlett:")
print(f"   ‚Üí œá¬≤ = {bartlett_resultado['chi2']:.4f}, p < 0.05")
print(f"   ‚Üí Dados s√£o apropriados para an√°lise fatorial ‚úì")

print(f"\n2. √çndice KMO:")
print(f"   ‚Üí KMO = {kmo_geral:.4f} ({interpretar_kmo(kmo_geral)})")
print(f"   ‚Üí Amostra √© adequada para an√°lise fatorial ‚úì")

print(f"\n3. Crit√©rio de Kaiser (Autovalor > 1):")
print(f"   ‚Üí Recomenda {num_componentes_kaiser} componentes/fatores")

print(f"\n4. Melhor Ajuste (M√°xima Vari√¢ncia Explicada):")
print(f"   ‚Üí {melhor_resultado['n_fatores']} fatores explicam {melhor_resultado['var_explicada']:.4f} da vari√¢ncia")

# ============================================================================
# 4. ESTRUTURA RECOMENDADA
# ============================================================================

print("\n\n" + "="*120)
print("4. ESTRUTURA RECOMENDADA DO MODELO")
print("="*120)

# Usar resultado com 4 fatores (mais pr√≥ximo do modelo te√≥rico)
resultado_4_fatores = [r for r in resultados_afe if r['n_fatores'] == 4][0]

print(f"\nN√∫mero de Fatores: 4 (Alinhado com modelo te√≥rico)")
print(f"Vari√¢ncia Explicada: {resultado_4_fatores['var_explicada']:.4f}")

print(f"\nDistribui√ß√£o de Quest√µes por Fator (Com Rota√ß√£o Varimax):")
print("-" * 120)

for fator_idx in sorted(resultado_4_fatores['alocacoes'].keys()):
    questoes_fator = sorted(resultado_4_fatores['alocacoes'][fator_idx],
                           key=lambda x: abs(x['carga']), reverse=True)

    if questoes_fator:
        print(f"\nFator {fator_idx + 1}: ({len(questoes_fator)} itens)")
        for item in questoes_fator:
            print(f"  {item['questao']}: {item['carga']:>8.4f}")
    else:
        print(f"\nFator {fator_idx + 1}: (0 itens)")

# ============================================================================
# SALVAR RESULTADOS
# ============================================================================

caminho_resultado = 'afe_kmo_bartlett_resultados.txt'

with open(caminho_resultado, 'w', encoding='utf-8') as f:
    f.write("="*120 + "\n")
    f.write("AN√ÅLISE FATORIAL EXPLORAT√ìRIA (AFE) - RESULTADOS COMPLETOS\n")
    f.write("="*120 + "\n\n")

    f.write("TESTES DE ADEQUA√á√ÉO\n\n")
    f.write(f"Teste de Bartlett:\n")
    f.write(f"  œá¬≤ = {bartlett_resultado['chi2']:.4f}\n")
    f.write(f"  df = {bartlett_resultado['df']}\n")
    f.write(f"  p-valor = {bartlett_resultado['p_value']:.6f}\n")
    f.write(f"  Status: {'Significativo ‚úì' if bartlett_resultado['p_value'] < 0.05 else 'N√£o significativo ‚úó'}\n\n")

    f.write(f"√çndice KMO:\n")
    f.write(f"  KMO Geral = {kmo_geral:.4f}\n")
    f.write(f"  Interpreta√ß√£o: {interpretar_kmo(kmo_geral)}\n")
    f.write(f"  Status: {'Adequado ‚úì' if kmo_geral > 0.5 else 'Inadequado ‚úó'}\n\n")

    f.write("CRIT√âRIO DE KAISER\n\n")
    f.write(f"N√∫mero de componentes com autovalor > 1: {num_componentes_kaiser}\n\n")

    f.write("VARI√ÇNCIA EXPLICADA\n\n")
    for resultado in resultados_afe:
        f.write(f"{resultado['n_fatores']} fatores: {resultado['var_explicada']:.4f}\n")

print(f"\n‚úì Resultado salvo em: {caminho_resultado}")

print("\n" + "="*120)
print("AN√ÅLISE FATORIAL EXPLORAT√ìRIA - CONCLU√çDA")
print("="*120)