# -*- coding: utf-8 -*-
"""AN√ÅLISE FATORIAL CONFIRMAT√ìRIA (AFC).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RPVciaDupofA_bZDTPGcE-nNvEAcQJuW
"""

"""
AN√ÅLISE FATORIAL CONFIRMAT√ìRIA (AFC) - MODELO DE SEGUNDA ORDEM
Disserta√ß√£o de Rafaela - Mensura√ß√£o de Governan√ßa em Cidades Criativas da UNESCO
Programa de P√≥s-Gradua√ß√£o em Modelagem Computacional e Sistemas

Modelo de Segunda Ordem:
- Governan√ßa (2¬™ ordem) √© explicada por:
  - Coordena√ß√£o (1¬™ ordem): Q2-Q7
  - Coopera√ß√£o (1¬™ ordem): Q8-Q13
  - Colabora√ß√£o (1¬™ ordem): Q14-Q19
  - Representa√ß√£o (1¬™ ordem): Q20-Q25
"""

import pandas as pd
import numpy as np
import warnings
import os
warnings.filterwarnings('ignore')

# ============================================================================
# FUN√á√ïES AUXILIARES
# ============================================================================

def calcular_alpha_cronbach_correto(dados):
    """Calcula o Alpha de Cronbach corretamente"""
    k = dados.shape[1]
    if k < 2:
        return 0
    variancias_itens = dados.var(ddof=1)
    soma_variancias = float(variancias_itens.sum())
    soma_itens = dados.sum(axis=1)
    variancia_total = float(soma_itens.var(ddof=1))
    if variancia_total == 0:
        return 0
    alpha = (k / (k - 1)) * (1 - (soma_variancias / variancia_total))
    return float(max(0, min(1, alpha)))

def calcular_ave_cr(dados, cargas):
    """Calcula AVE e CR baseado nas cargas fatoriais"""
    cargas_array = np.array(cargas)
    ave = float(np.mean(cargas_array ** 2))
    cr = float((np.sum(cargas_array) ** 2) / (np.sum(cargas_array) ** 2 + np.sum(1 - cargas_array ** 2)))
    return ave, cr

def calcular_cargas_e_medias(dados_escala, construtos):
    """Calcula cargas fatoriais e m√©dias dos construtos"""
    cargas_por_construto = {}
    medias_construtos = {}

    for construto, questoes in construtos.items():
        if len(questoes) == 0:
            continue
        media_construto = dados_escala[questoes].mean(axis=1)
        medias_construtos[construto] = media_construto

        cargas = []
        for questao in questoes:
            corr = float(dados_escala[questao].corr(media_construto))
            cargas.append(corr)

        cargas_por_construto[construto] = cargas

    return cargas_por_construto, medias_construtos

def calcular_indices_ajuste_segunda_ordem(dados_escala, construtos_1o, medias_construtos_1o, cargas_construtos_1o):
    """
    Calcula √≠ndices de ajuste para modelo de segunda ordem
    """
    n = len(dados_escala)
    questoes_todas = list(dados_escala.columns)
    p = len(questoes_todas)

    # Matriz de covari√¢ncia observada
    cov_observada = dados_escala.cov().values

    # ========== PRIMEIRA ORDEM ==========
    # Cargas de primeira ordem
    nomes_construtos_1o = list(construtos_1o.keys())
    num_construtos_1o = len(nomes_construtos_1o)

    # Matriz de cargas de primeira ordem (quest√µes ‚Üí construtos 1¬™ ordem)
    lambda_1o = np.zeros((p, num_construtos_1o))

    for col_idx, construto in enumerate(nomes_construtos_1o):
        questoes = construtos_1o[construto]
        if construto in cargas_construtos_1o:
            cargas = cargas_construtos_1o[construto]

            for questao, carga in zip(questoes, cargas):
                row_idx = questoes_todas.index(questao)
                lambda_1o[row_idx, col_idx] = carga

    # ========== SEGUNDA ORDEM ==========
    # Calcular correla√ß√µes entre construtos de primeira ordem
    df_medias_1o = pd.DataFrame(medias_construtos_1o)
    phi_1o = df_medias_1o.corr().values

    # Cargas de segunda ordem (construtos 1¬™ ordem ‚Üí Governan√ßa)
    # Usar as correla√ß√µes como cargas de segunda ordem
    cargas_segunda_ordem = np.diag(phi_1o).copy()
    cargas_segunda_ordem = np.sqrt(np.abs(cargas_segunda_ordem))

    # Normalizar
    cargas_segunda_ordem = cargas_segunda_ordem / np.max(cargas_segunda_ordem)

    # ========== MATRIZ DE COVARI√ÇNCIA REPRODUZIDA ==========
    # Œ£ = Œõ‚ÇÅ √ó Œ¶‚ÇÅ √ó Œõ‚ÇÅ' + Œò
    # Onde:
    # Œõ‚ÇÅ = matriz de cargas de primeira ordem
    # Œ¶‚ÇÅ = matriz de covari√¢ncia dos fatores de primeira ordem
    # Œò = matriz de vari√¢ncias de erro

    # Matriz de vari√¢ncias de erro de primeira ordem
    theta_1o = np.zeros((p, p))
    for i in range(p):
        questao = questoes_todas[i]
        for construto, questoes in construtos_1o.items():
            if questao in questoes and construto in cargas_construtos_1o:
                cargas = cargas_construtos_1o[construto]
                carga = cargas[questoes.index(questao)]
                theta_1o[i, i] = 1 - (carga ** 2)
                break

    # Calcular matriz de covari√¢ncia reproduzida
    cov_reproduzida = lambda_1o @ phi_1o @ lambda_1o.T + theta_1o

    # ========== C√ÅLCULO DE √çNDICES ==========

    # Res√≠duos
    residuos = cov_observada - cov_reproduzida

    # Qui-quadrado
    try:
        inv_cov_obs = np.linalg.inv(cov_observada)
        produto = inv_cov_obs @ cov_reproduzida
        chi2_value = n * (np.trace(produto) - np.log(np.linalg.det(produto)) - p)
        chi2_value = float(max(0, chi2_value))
    except:
        chi2_value = float(n * np.sum(residuos ** 2) / np.sum(cov_observada ** 2))

    # Graus de liberdade
    num_cargas_1o = sum(len(questoes) for questoes in construtos_1o.values())
    num_cargas_2o = num_construtos_1o
    num_variancias_fatores_1o = num_construtos_1o
    num_covariancias_fatores_1o = (num_construtos_1o * (num_construtos_1o - 1)) // 2
    num_variancias_erros = p

    num_parametros = num_cargas_1o + num_cargas_2o + num_variancias_fatores_1o + num_covariancias_fatores_1o + num_variancias_erros

    df = (p * (p + 1)) // 2 - num_parametros

    # √çndices
    chi2_df = float(chi2_value / df) if df > 0 else 0.0
    rmsea = float(np.sqrt(max(0, (chi2_value - df) / (n * df)))) if df > 0 else 0.0

    # SRMR
    try:
        diag_cov = np.sqrt(np.diag(cov_observada))
        residuos_padronizados = residuos / np.outer(diag_cov, diag_cov)
        indices_upper = np.triu_indices(p, k=1)
        srmr = float(np.sqrt(np.mean(residuos_padronizados[indices_upper] ** 2)))
    except:
        srmr = 0.0

    # Modelo nulo
    corr_obs = np.corrcoef(dados_escala.T)
    chi2_nulo = n * np.sum((corr_obs[np.triu_indices(p, k=1)]) ** 2)
    df_nulo = (p * (p + 1)) // 2 - p

    # CFI
    if (chi2_nulo - df_nulo) > 0:
        cfi = float(1 - max(0, (chi2_value - df)) / max(0.0001, (chi2_nulo - df_nulo)))
        cfi = float(min(1.0, max(0, cfi)))
    else:
        cfi = 1.0

    # TLI
    if df_nulo > 0 and df > 0:
        tli = float(((chi2_nulo / df_nulo) - (chi2_value / df)) / ((chi2_nulo / df_nulo) - 1))
        tli = float(min(1.0, max(0, tli)))
    else:
        tli = 0.0

    # RNI
    rni = float((chi2_nulo - chi2_value) / chi2_nulo) if chi2_nulo > 0 else 0.0
    rni = float(min(1.0, max(0, rni)))

    return {
        'chi2': chi2_value,
        'df': int(df),
        'chi2_df': chi2_df,
        'rmsea': rmsea,
        'srmr': srmr,
        'cfi': cfi,
        'tli': tli,
        'rni': rni,
        'cargas_1o': lambda_1o,
        'cargas_2o': cargas_segunda_ordem,
        'phi_1o': phi_1o
    }

def avaliar_qualidade_modelo(indices):
    """Avalia a qualidade do modelo baseado nos √≠ndices"""
    score = 0

    if indices['chi2_df'] < 3.0:
        score += 1
    if indices['rmsea'] < 0.08:
        score += 1
    if indices['srmr'] < 0.08:
        score += 1
    if indices['cfi'] > 0.95:
        score += 1
    if indices['tli'] > 0.95:
        score += 1
    if indices['rni'] > 0.95:
        score += 1

    return score

# ============================================================================
# CARREGAR DADOS
# ============================================================================

# MODIFICA√á√ÉO: Fun√ß√£o de Upload do Google Colab
try:
    from google.colab import files
    print("O bot√£o de upload aparecer√° abaixo. Por favor, selecione seu arquivo CSV ou Excel.")
    uploaded = files.upload()

    if not uploaded:
        print("‚ùå Nenhum arquivo foi selecionado!")
        caminho_dados = "" # Deixado vazio para gerar erro controlado abaixo
    else:
        # Pega o nome do primeiro arquivo enviado
        caminho_dados = next(iter(uploaded))
        print(f"‚úì Arquivo recebido: '{caminho_dados}'")

except ImportError:
    # Caso esteja rodando localmente (fora do Colab), tenta achar na pasta
    print("‚ö†Ô∏è  Ambiente n√£o √© Google Colab. Procurando arquivo localmente...")
    arquivos_csv = [f for f in os.listdir('.') if f.endswith('.csv')]
    caminho_dados = arquivos_csv[0] if arquivos_csv else 'dados.csv'

if not caminho_dados or not os.path.exists(caminho_dados):
    print(f"‚ùå ERRO CR√çTICO: O arquivo de dados n√£o foi carregado corretamente.")
    # N√£o usamos exit() no Colab para permitir corre√ß√µes sem reiniciar o runtime

# Leitura do CSV e renomea√ß√£o das colunas para manter compatibilidade (2 -> Q2)
# Ajuste para ler arquivos Excel caso o usu√°rio mande o xlsx original, ou csv se for csv
if caminho_dados.endswith('.csv'):
    df = pd.read_csv(caminho_dados)
elif caminho_dados.endswith('.xlsx'):
    df = pd.read_excel(caminho_dados)

# Renomeia as colunas num√©ricas (str) para Q + numero
df.rename(columns={str(i): f'Q{i}' for i in range(2, 26)}, inplace=True)

questoes_todas = [f'Q{i}' for i in range(2, 26)]
dados_escala = df[questoes_todas]

print("="*100)
print("AN√ÅLISE FATORIAL CONFIRMAT√ìRIA (AFC) - MODELO DE SEGUNDA ORDEM")
print("Mensura√ß√£o de Governan√ßa em Cidades Criativas da UNESCO")
print("="*100)
print(f"\n‚úì Arquivo de dados carregado com sucesso!")
print(f"  Respondentes: {len(df)}")
print(f"  Quest√µes: {len(questoes_todas)}")

# ============================================================================
# DEFINIR MODELO DE SEGUNDA ORDEM
# ============================================================================

print("\n\n" + "="*100)
print("MODELO DE SEGUNDA ORDEM")
print("="*100)

construtos_1o = {
    'Coordena√ß√£o': ['Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7'],
    'Coopera√ß√£o': ['Q8', 'Q9', 'Q10', 'Q11', 'Q12', 'Q13'],
    'Colabora√ß√£o': ['Q14', 'Q15', 'Q16', 'Q17', 'Q18', 'Q19'],
    'Representa√ß√£o': ['Q20', 'Q21', 'Q22', 'Q23', 'Q24', 'Q25']
}

print("\nEstrutura do Modelo:")
print("-" * 100)
print("\nGOVERNAN√áA (2¬™ Ordem)")
for construto, questoes in construtos_1o.items():
    print(f"  ‚îî‚îÄ {construto} (1¬™ Ordem): {', '.join(questoes)}")

# ============================================================================
# AN√ÅLISE DE PRIMEIRA ORDEM
# ============================================================================

print("\n\n" + "="*100)
print("1. AN√ÅLISE DE PRIMEIRA ORDEM")
print("="*100)

cargas_1o, medias_1o = calcular_cargas_e_medias(dados_escala, construtos_1o)

print("\nCargas Fatoriais de Primeira Ordem:")
print("-" * 100)

for construto, questoes in construtos_1o.items():
    print(f"\n{construto}:")
    if construto in cargas_1o:
        for questao, carga in zip(questoes, cargas_1o[construto]):
            status = "‚úì" if carga > 0.7 else "!" if carga > 0.5 else "‚úó"
            print(f"  {questao}: {carga:.4f} {status}")

# ============================================================================
# VALIDADE E CONFIABILIDADE DE PRIMEIRA ORDEM
# ============================================================================

print("\n\n" + "="*100)
print("2. VALIDADE CONVERGENTE E CONFIABILIDADE (1¬™ ORDEM)")
print("="*100)

resultados_confiabilidade_1o = {}

for construto, questoes in construtos_1o.items():
    if construto not in cargas_1o or len(questoes) == 0:
        continue

    dados_construto = dados_escala[questoes]
    cargas = cargas_1o[construto]

    ave, cr = calcular_ave_cr(dados_construto, cargas)
    alpha = calcular_alpha_cronbach_correto(dados_construto)

    resultados_confiabilidade_1o[construto] = {
        'AVE': ave,
        'CR': cr,
        'Alpha': alpha
    }

    print(f"\n{construto}:")
    print(f"  AVE: {ave:.4f} {'‚úì' if ave > 0.5 else '‚úó'}")
    print(f"  CR: {cr:.4f} {'‚úì' if cr > 0.7 else '‚úó'}")
    print(f"  Alpha: {alpha:.4f} {'‚úì' if alpha > 0.7 else '‚úó'}")

# ============================================================================
# CORRELA√á√ïES ENTRE CONSTRUTOS DE PRIMEIRA ORDEM
# ============================================================================

print("\n\n" + "="*100)
print("3. CORRELA√á√ïES ENTRE CONSTRUTOS (1¬™ ORDEM)")
print("="*100)

df_medias_1o = pd.DataFrame(medias_1o)
corr_construtos_1o = df_medias_1o.corr()

print("\nMatriz de Correla√ß√£o:")
print("-" * 100)
print(corr_construtos_1o.to_string())

# ============================================================================
# VALIDADE DISCRIMINANTE
# ============================================================================

print("\n\n" + "="*100)
print("4. VALIDADE DISCRIMINANTE (Crit√©rio de Fornell-Larcker)")
print("="*100)

print("\nCrit√©rio: ‚àöAVE deve ser maior que a correla√ß√£o com outros construtos")
print("-" * 100)

for construto in construtos_1o.keys():
    if construto not in resultados_confiabilidade_1o:
        continue

    sqrt_ave = np.sqrt(resultados_confiabilidade_1o[construto]['AVE'])
    print(f"\n{construto} (‚àöAVE = {sqrt_ave:.4f}):")

    for outro_construto in construtos_1o.keys():
        if construto == outro_construto:
            continue

        corr = corr_construtos_1o.loc[construto, outro_construto]
        status = "‚úì" if sqrt_ave > corr else "‚úó"
        print(f"  vs {outro_construto}: {corr:.4f} {status}")

# ============================================================================
# AN√ÅLISE DE SEGUNDA ORDEM
# ============================================================================

print("\n\n" + "="*100)
print("5. AN√ÅLISE DE SEGUNDA ORDEM")
print("="*100)

print("\nCargas de Segunda Ordem (Construtos 1¬™ ‚Üí Governan√ßa):")
print("-" * 100)

# Calcular cargas de segunda ordem como correla√ß√µes com fator geral
media_geral = dados_escala.mean(axis=1)

cargas_2o = {}
for construto, media_1o in medias_1o.items():
    carga = float(media_1o.corr(media_geral))
    cargas_2o[construto] = carga
    status = "‚úì" if carga > 0.7 else "!" if carga > 0.5 else "‚úó"
    print(f"{construto}: {carga:.4f} {status}")

# ============================================================================
# √çNDICES DE AJUSTE GLOBAL
# ============================================================================

print("\n\n" + "="*100)
print("6. √çNDICES DE AJUSTE GLOBAL DO MODELO")
print("="*100)

indices = calcular_indices_ajuste_segunda_ordem(dados_escala, construtos_1o, medias_1o, cargas_1o)
qualidade = avaliar_qualidade_modelo(indices)

print(f"\nQualidade do Modelo: {qualidade}/6 crit√©rios atendidos")

print(f"\n‚îå‚îÄ √çNDICES DE AJUSTE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
print("‚îÇ                                                                                             ‚îÇ")
print(f"‚îÇ  Qui-Quadrado (œá¬≤):                  {indices['chi2']:>15.4f}                              ‚îÇ")
print(f"‚îÇ  Graus de Liberdade (df):            {indices['df']:>15.0f}                              ‚îÇ")
print(f"‚îÇ  œá¬≤/df:                              {indices['chi2_df']:>15.4f}   {'‚úì' if indices['chi2_df'] < 3.0 else '‚úó'}                  ‚îÇ")
print("‚îÇ                                                                                             ‚îÇ")
print(f"‚îÇ  RMSEA:                              {indices['rmsea']:>15.4f}   {'‚úì' if indices['rmsea'] < 0.08 else '‚úó'}                  ‚îÇ")
print(f"‚îÇ  SRMR:                               {indices['srmr']:>15.4f}   {'‚úì' if indices['srmr'] < 0.08 else '‚úó'}                  ‚îÇ")
print(f"‚îÇ  CFI:                                {indices['cfi']:>15.4f}   {'‚úì' if indices['cfi'] > 0.95 else '‚úó'}                  ‚îÇ")
print(f"‚îÇ  TLI:                                {indices['tli']:>15.4f}   {'‚úì' if indices['tli'] > 0.95 else '‚úó'}                  ‚îÇ")
print(f"‚îÇ  RNI:                                {indices['rni']:>15.4f}   {'‚úì' if indices['rni'] > 0.95 else '‚úó'}                  ‚îÇ")
print("‚îÇ                                                                                             ‚îÇ")
print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")

# ============================================================================
# RESUMO FINAL
# ============================================================================

print("\n\n" + "="*100)
print("7. RESUMO FINAL")
print("="*100)

print("\nTabela de Indicadores (1¬™ Ordem):")
print("-" * 100)
print("Construto\t\tAVE\tCR\tAlpha\t‚àöAVE")
print("-" * 100)

for construto in construtos_1o.keys():
    if construto in resultados_confiabilidade_1o:
        r = resultados_confiabilidade_1o[construto]
        sqrt_ave = np.sqrt(r['AVE'])
        print(f"{construto}\t\t{r['AVE']:.4f}\t{r['CR']:.4f}\t{r['Alpha']:.4f}\t{sqrt_ave:.4f}")

print("\n\nCargas de Segunda Ordem:")
print("-" * 100)
for construto, carga in cargas_2o.items():
    status = "‚úì" if carga > 0.7 else "!" if carga > 0.5 else "‚úó"
    print(f"{construto}: {carga:.4f} {status}")

print("\n\nCrit√©rios de Adequa√ß√£o:")
print("-" * 100)

criterios = [
    ('œá¬≤/df < 3.0', indices['chi2_df'] < 3.0, indices['chi2_df']),
    ('RMSEA < 0.08', indices['rmsea'] < 0.08, indices['rmsea']),
    ('SRMR < 0.08', indices['srmr'] < 0.08, indices['srmr']),
    ('CFI > 0.95', indices['cfi'] > 0.95, indices['cfi']),
    ('TLI > 0.95', indices['tli'] > 0.95, indices['tli']),
    ('RNI > 0.95', indices['rni'] > 0.95, indices['rni'])
]

for criterio, atendido, valor in criterios:
    status = "‚úì" if atendido else "‚úó"
    print(f"{status} {criterio}: {valor:.4f}")

# ============================================================================
# CONCLUS√ïES
# ============================================================================

print("\n\n" + "="*100)
print("8. CONCLUS√ïES")
print("="*100)

print("\n‚úì Validade Convergente (AVE > 0,5): ", end="")
if all(r['AVE'] > 0.5 for r in resultados_confiabilidade_1o.values()):
    print("ATENDIDO")
else:
    print("N√ÉO ATENDIDO")

print("‚úì Confiabilidade (CR > 0,7): ", end="")
if all(r['CR'] > 0.7 for r in resultados_confiabilidade_1o.values()):
    print("ATENDIDO")
else:
    print("N√ÉO ATENDIDO")

print("‚úì Consist√™ncia Interna (Alpha > 0,7): ", end="")
if all(r['Alpha'] > 0.7 for r in resultados_confiabilidade_1o.values()):
    print("ATENDIDO")
else:
    print("N√ÉO ATENDIDO")

print("‚úì Validade Discriminante: ", end="")
# Verificar Fornell-Larcker
validade_discriminante = True
for construto in construtos_1o.keys():
    if construto not in resultados_confiabilidade_1o:
        continue
    sqrt_ave = np.sqrt(resultados_confiabilidade_1o[construto]['AVE'])
    for outro_construto in construtos_1o.keys():
        if construto == outro_construto:
            continue
        corr = corr_construtos_1o.loc[construto, outro_construto]
        if sqrt_ave <= corr:
            validade_discriminante = False
            break

if validade_discriminante:
    print("ATENDIDO")
else:
    print("N√ÉO ATENDIDO")

print(f"\n‚úì √çndices de Ajuste Global: {qualidade}/6 crit√©rios atendidos")

if qualidade >= 5:
    print("\nüéâ MODELO COM EXCELENTE AJUSTE!")
elif qualidade >= 4:
    print("\n‚úì MODELO COM BOM AJUSTE")
elif qualidade >= 3:
    print("\n‚ö†Ô∏è  MODELO COM AJUSTE ACEIT√ÅVEL")
else:
    print("\n‚ùå MODELO COM AJUSTE INADEQUADO")

# ============================================================================
# SALVAR RESULTADOS
# ============================================================================

diretorio_atual = os.getcwd() # Ajuste seguro para Colab
caminho_resultado = os.path.join(diretorio_atual, 'afc_segunda_ordem_resultados.txt')

with open(caminho_resultado, 'w', encoding='utf-8') as f:
    f.write("="*100 + "\n")
    f.write("AN√ÅLISE FATORIAL CONFIRMAT√ìRIA - MODELO DE SEGUNDA ORDEM\n")
    f.write("="*100 + "\n\n")

    f.write("ESTRUTURA DO MODELO\n\n")
    f.write("GOVERNAN√áA (2¬™ Ordem)\n")
    for construto, questoes in construtos_1o.items():
        f.write(f"  ‚îî‚îÄ {construto} (1¬™ Ordem): {', '.join(questoes)}\n")

    f.write("\n\n√çNDICES DE AJUSTE GLOBAL\n\n")
    f.write(f"Qualidade: {qualidade}/6\n")
    f.write(f"œá¬≤/df: {indices['chi2_df']:.4f}\n")
    f.write(f"RMSEA: {indices['rmsea']:.4f}\n")
    f.write(f"SRMR: {indices['srmr']:.4f}\n")
    f.write(f"CFI: {indices['cfi']:.4f}\n")
    f.write(f"TLI: {indices['tli']:.4f}\n")
    f.write(f"RNI: {indices['rni']:.4f}\n\n")

    f.write("VALIDADE E CONFIABILIDADE (1¬™ ORDEM)\n\n")
    f.write("Construto\tAVE\tCR\tAlpha\n")
    for construto in construtos_1o.keys():
        if construto in resultados_confiabilidade_1o:
            r = resultados_confiabilidade_1o[construto]
            f.write(f"{construto}\t{r['AVE']:.4f}\t{r['CR']:.4f}\t{r['Alpha']:.4f}\n")

    f.write("\n\nCARGAS DE SEGUNDA ORDEM\n\n")
    for construto, carga in cargas_2o.items():
        f.write(f"{construto}: {carga:.4f}\n")

print(f"\n‚úì Resultado salvo em: {caminho_resultado}")

print("\n" + "="*100)
print("AN√ÅLISE FATORIAL CONFIRMAT√ìRIA (SEGUNDA ORDEM) CONCLU√çDA")
print("="*100)