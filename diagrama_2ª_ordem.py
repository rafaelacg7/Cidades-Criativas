# -*- coding: utf-8 -*-
"""Diagrama 2ª ordem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/166qo2fbB95ABQger948EO4ahTWWmAqwA
"""

import matplotlib.pyplot as plt
import networkx as nx

def desenhar_modelo_afc():
    G = nx.DiGraph()

    # 1. Definir os Nós (Nodes)
    # Fator de 2ª Ordem
    G.add_node("GOVERNANÇA", layer=0)

    # Fatores de 1ª Ordem
    dimensoes = ["Coordenação", "Cooperação", "Colaboração", "Representação"]
    for dim in dimensoes:
        G.add_node(dim, layer=1)
        G.add_edge("GOVERNANÇA", dim) # Conecta Governança às dimensões

    # Itens (Questões)
    questoes = {
        "Coordenação": ["Q2", "Q3", "Q4", "Q5", "Q6", "Q7"],
        "Cooperação": ["Q8", "Q9", "Q10", "Q11", "Q12", "Q13"],
        "Colaboração": ["Q14", "Q15", "Q16", "Q17", "Q18", "Q19"],
        "Representação": ["Q20", "Q21", "Q22", "Q23", "Q24", "Q25"]
    }

    for dim, itens in questoes.items():
        for item in itens:
            G.add_node(item, layer=2)
            G.add_edge(dim, item) # Conecta Dimensão à Questão

    # 2. Configurar o Layout (Hierárquico)
    pos = {}

    # Posição da Governança (Topo/Esquerda)
    pos["GOVERNANÇA"] = (0, 0.5)

    # Posição das Dimensões
    y_dim = [0.8, 0.6, 0.4, 0.2]
    for i, dim in enumerate(dimensoes):
        pos[dim] = (1, y_dim[i])

    # Posição das Questões
    y_start = 0.9
    step = 1.0 / 25 # Espaço entre questões
    current_y = 0.9

    # Ajuste manual para alinhar questões perto de suas dimensões
    # Vamos distribuir as questões verticalmente na direita
    layer_3_x = 2

    # Recalcular layout simples para visualização rápida
    pos = nx.shell_layout(G, nlist=[["GOVERNANÇA"], dimensoes, [item for sublist in questoes.values() for item in sublist]])

    # Melhorando visualização hierárquica forçada (tipo árvore deitada)
    pos["GOVERNANÇA"] = (-1.5, 0)

    y_coords = [3, 1, -1, -3] # Alturas das 4 dimensões
    for idx, dim in enumerate(dimensoes):
        pos[dim] = (0, y_coords[idx])

        # Questões daquela dimensão
        itens_dim = questoes[dim]
        for i_q, q in enumerate(itens_dim):
            # Espalhar as questões ao lado da dimensão
            pos[q] = (1.5, y_coords[idx] + (i_q - 2.5) * 0.3)

    # 3. Desenhar
    plt.figure(figsize=(12, 8))

    # Desenhar nós
    nx.draw_networkx_nodes(G, pos, node_size=2000, node_color='lightblue', nodelist=["GOVERNANÇA"])
    nx.draw_networkx_nodes(G, pos, node_size=1500, node_color='lightgreen', nodelist=dimensoes)
    nx.draw_networkx_nodes(G, pos, node_size=500, node_color='lightgrey', nodelist=[n for n in G.nodes if n not in dimensoes and n != "GOVERNANÇA"])

    # Desenhar bordas e labels
    nx.draw_networkx_edges(G, pos, edge_color='gray', arrows=True, arrowsize=20)
    nx.draw_networkx_labels(G, pos, font_size=9, font_weight="bold")

    plt.title("Diagrama do Modelo de 2ª Ordem: Governança em Cidades Criativas", fontsize=14)
    plt.axis('off')
    plt.tight_layout()
    plt.show()

desenhar_modelo_afc()

import matplotlib.pyplot as plt
import networkx as nx

def desenhar_modelo_afc_otimizado():
    G = nx.DiGraph()

    # 1. Definição da Estrutura
    governanca = "GOVERNANÇA\n(2ª Ordem)"
    dimensoes = ["Coordenação", "Cooperação", "Colaboração", "Representação"]
    questoes = {
        "Coordenação": ["Q2", "Q3", "Q4", "Q5", "Q6", "Q7"],
        "Cooperação": ["Q8", "Q9", "Q10", "Q11", "Q12", "Q13"],
        "Colaboração": ["Q14", "Q15", "Q16", "Q17", "Q18", "Q19"],
        "Representação": ["Q20", "Q21", "Q22", "Q23", "Q24", "Q25"]
    }

    # 2. Posicionamento Manual (Ajustado para ser compacto e horizontal)
    pos = {}

    # Camada 1: Governança (Mais à esquerda)
    pos[governanca] = (0, 0)

    # Camada 2: Dimensões (Mais próximas da governança para encurtar as setas)
    y_coords = [1.5, 0.5, -0.5, -1.5]
    for idx, dim in enumerate(dimensoes):
        pos[dim] = (0.8, y_coords[idx]) # Distância X de apenas 0.8
        G.add_edge(governanca, dim)

        # Camada 3: Questões (Bem próximas das dimensões)
        itens_dim = questoes[dim]
        for i_q, q in enumerate(itens_dim):
            # Espaçamento vertical muito fino (0.15) para as questões caberem juntas
            pos[q] = (1.6, y_coords[idx] + (i_q - 2.5) * 0.15)
            G.add_edge(dim, q)

    # 3. Desenho Profissional
    plt.figure(figsize=(10, 6)) # Tamanho ideal para "meia página"

    # Desenhar os nós por categoria (tamanhos diferentes)
    nx.draw_networkx_nodes(G, pos, nodelist=[governanca], node_size=3000, node_color='#1f77b4', node_shape='o')
    nx.draw_networkx_nodes(G, pos, nodelist=dimensoes, node_size=2000, node_color='#aec7e8')
    nx.draw_networkx_nodes(G, pos, nodelist=[n for n in G.nodes if "Q" in str(n)],
                           node_size=400, node_color='#f5f5f5', node_shape='s')

    # Desenhar as setas (curtas e discretas)
    nx.draw_networkx_edges(G, pos, edge_color='#666666', arrows=True, arrowsize=10, width=1)

    # Desenhar os rótulos (Labels)
    # Ajuste de fonte: 10 para o título, 9 para dimensões, 7 para as questões
    labels = {n: n for n in G.nodes}
    nx.draw_networkx_labels(G, pos, labels, font_size=8, font_family='sans-serif', font_weight='bold')

    plt.title("Modelo de Mensuração: Governança em Cidades Criativas", fontsize=12, pad=20)
    plt.axis('off')

    # Salva a imagem com bordas brancas mínimas
    plt.savefig("diagrama_afc_networkx.png", dpi=300, bbox_inches='tight')
    plt.show()

desenhar_modelo_afc_otimizado()

"""Os 2 códigos estò"""